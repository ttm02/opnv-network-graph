import datetime
import os
from time import strftime
from tqdm import tqdm

from parse_input_file import get_line_info_from_file
from network import Network
import json

file_to_read = "data/20250210_fahrplaene_gesamtdeutschland/126_HEAGTRAM/NX-PI-01_DE_NAP_LINE_126-HEAGTRAM-6_20250208.xml"
dir_to_read = "data/20250210_fahrplaene_gesamtdeutschland/126_HEAGTRAM"
# dir_to_read="data/20250210_fahrplaene_gesamtdeutschland"

network = Network()
all_stops = {}

# Pre-count total files
total_files = sum(len(files) for _, _, files in os.walk(dir_to_read))

with tqdm(total=total_files, desc="Parse files", unit="files") as pbar:
    for root, dirs, files in os.walk(dir_to_read):
        path = root.split(os.sep)
        for file in files:
            if file.endswith(".xml"):
                qualified_path = os.path.join(root, file)
                # print("Read " + qualified_path)
                new_network, stops = get_line_info_from_file(qualified_path)
                network.merge(new_network)
                for stop_id, info in stops.items():
                    if stop_id not in all_stops:
                        all_stops[stop_id] = info
                    else:
                        pass
                        # there is some ambiguity in the data regarding stop naming
                        # assert (all_stops[stop_id] == info)

            pbar.update(1)

print("stops:")
print(len(all_stops))

import difflib


# function is generated by AI
def find_closest_key_by_name(target_name, data):
    # Create a mapping of names to keys
    name_to_key = {v['Name']: k for k, v in data.items()}

    # Try exact match first
    if target_name in name_to_key:
        return name_to_key[target_name]

    # Find the closest match using difflib
    closest_match = difflib.get_close_matches(target_name, name_to_key.keys(), n=1, cutoff=0.5)

    if closest_match:
        return name_to_key[closest_match[0]]  # Return the key of the closest match
    return None  # No close match found


luisenplatz = find_closest_key_by_name("Darmstadt Luisenplatz", all_stops)
schloss = find_closest_key_by_name("Darmstadt Schloss", all_stops)

# connections between them should be plenty
print("Fahrten between " + all_stops[luisenplatz]["Name"] + " and " + all_stops[schloss]["Name"])
print(len(network.stops[luisenplatz][schloss]))

# print the timetable
# for info in network.stops[luisenplatz][schloss]:
#    print(info[0].strftime("%H:%M")+" "+info[2])

class CustomJSONEncoder(json.JSONEncoder):
    def default(self, obj):
        if isinstance(obj, datetime.time):
            return obj.strftime("%H:%M")  # Convert to string
        return super().default(obj)

with open('network.json', 'w') as f:
    json.dump(network.stops, f,cls=CustomJSONEncoder)
with open('stations.json', 'w') as f:
    json.dump(all_stops, f)
